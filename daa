Program1:
import java.util.Random;
import java.util.Scanner;
public class Selsort
{
public static void selectionSort(int[] nums)
{
 for (int i = 0; i < nums.length; i++)
{
 // min is the index of the smallest element with an index greater or equal to i
 int min = i;
 for (int j = i + 1; j < nums.length; j++)
{
 if (nums[j] < nums[min])
 {
 min = j;
 }
 }
 // Swapping i-th and min-th elements
 int swap = nums[i];
 nums[i] = nums[min];
 nums[min] = swap;
 }
}
public static void main(String[] args)
{
 int[] array = new int[10000];
 for (int i = 0; i < array.length; i++) {
 array[i] = i;
 }
 // Shuffle array
 Collections.shuffle(Arrays.asList(array));
 // Print shuffled collection
 System.out.println(“ Unsorted Array List is:”)
 System.out.println(\tArrays.toString(array));

28
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
 long startTime = System.nanoTime();
System.out.println(“Selection Sort”);
selectionSort(array);
 long endTime = System.nanoTime();
 // Print sorted collection
System.out.println(“ the Sorted Array is:”);
 System.out.println(\tArrays.toString(array));
 // Print runtime in seconds
 System.out.println("Selection Sort runtime: " + (endTime - startTime)/1000000000);
}
Output:
Unsorted Array List is: ---------
the Sorted Array is: 0 1 2 3…..10000
Selection Sort runtime: ---
a) The elements generated using the random number generator
public static void main(String args[])
{
static int max=50000;
int n,i;
Scanner in=new Scanner(System.in);
Random rand=new Random();
System.out.println("Selectionsort Test");
/* Accept no.of Elements */
System.out.println("\nEnter the number of elements");
n=in.nextInt();
/* create array of n elements */
29
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
int arr[]=new int[max];
try
{
/* Generate Random Numbers */
for(i=0;i<n;i++)
arr[i]=rand.nextInt(100);
/* Print random numbers */
System.out.println("\nthe random elements are ");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long start_time=System.nanoTime();
/*call method Selection Sort*/
selectionSort(arr);
long end_time=System.nanoTime();
/* Print Sorted Array */
System.out.println("\nThe Elements After sorting");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long t=end_time - start_time;
System.out.println(“Time taken for execution is:”+t+” nanoseconds);
}
catch(ArrayIndexOutOfBoundsException ae)
{
System.out.println("Array Index reached maximum ");
}
}
Output:
Selectionsort Test
Enter the number of elements
10
the random elements are
17
31
30
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
81
44
91
24
87
42
57
17
The Elements after sorting
17
17
24
31
42
44
57
81
87
91
Time taken for execution is: nanoseconds
Note: For n=5000 to 50000 in step of 5000 note down the time in nanoseconds. Convert time in
seconds and plot the graph with n as x axis and time as y axis.
b) The elements read from a file
Create a text file in notepad and enter random numbers one in each line. Save the file as t.txt
public static void main(String args[])
{
int n,i;
FILE *f1;
int line[50];
int limit;
System.out.println("Selectionsort Test");
/* Accept no.of Elements */
System.out.println("\nEnter the number of elements");
n=in.nextInt();
/* create array of n elements */
int arr[]=new int[max];
31
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
try{
/* Elements from file are: */
f1= fopen(“t.txt”,”r”);
while(i<= n-1) && (fgets(line,50,f1)!=NULL))
{
fscanf(line,”%d”,&limit);
arr[i] = limit;
i++;
}
fclose(f1);
/* Print random numbers */
System.out.println("\nthe random elements are ");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long start_time=System.nanoTime();
/*call method Selection Sort*/
selectionSort(arr);
long end_time=System.nanoTime();
/* Print Sorted Array */
System.out.println("\nThe Elements After sorting");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long t=end_time - start_time;
System.out.println(“Time taken for execution is:”+t+” nanoseconds);
}
catch(ArrayIndexOutOfBoundsException ae)
{
System.out.println("Array Index reached maximum ");
}
}
}
32
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023


Module2
1. Sort a given set of n integer elements using Quick Sort method and compute its time
complexity. Run the program for varied values of n> 5000 and record the time taken to
sort. Plot a graph of the time taken versus n. The elements can be read from a file or can
be generated using the random number generator. Demonstrate using C++/Java how the
divide-and-conquer method works along with its time complexity analysis: worst case,
average case and best case.
Quick Sort using Divide and Conquer Technique:
Quick Sort divides the array according to the value of elements. It rearranges elements of a given
array A[0..n-1] to achieve its partition, where the elements before position s are smaller than or
equal to A[s] and all the elements after position s are greater than or equal to A[s].
A[0]……..A[s-1] A[s] A[s+1]…A[n-1]
All are <= A[s] All are >= A[s]
Pseudocode : QUICKSORT(a[l..r])
//Sorts a subarray by quicksort
//Input: A subarray A[l..r] of A[0..n-1],defined by its left and right indices l and r
//Output: Subarray A[l..r] sorted in nondecreasing order
{
if l<r
{
s← Partition(A[l..r]) //s is a split position
QUICKSORT(A[l..s-1])
QUICKSORT(A[s+1..r])
}
}
Pseudocode : Partition(A[l..r])
//Partition a subarray by using its first element as its pivot
//Input:A subarray A[l..r] of A[0..n-1],defined by its left and right indices l and r (l<r)
//Output:A partition of A[l..r],with the split position returned as this function’s value
{
p ← A[l]
i ← l; j ← r+1
repeat
{
repeat i ← i+1 until A[i] >=p and i<=high
repeat j ← j-1 until A[j] <=p
swap(A[i],A[j])
} until i>=j
33
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
swap(A[i],A[j]) // undo last swap when i>=j
swap(A[l],A[j])
return j
}
Program 1
a)The elements generated using the random number generator
import java.util.Random;
import java.util.Scanner;
public class QuickSort
{
static int max=50000;
public static int partition(int a[],int low,int high)
{
int i,j,temp,key;
key=a[low];
i=low;
j=high+1;
while(i<=j)
{
do
i++;
while (key>=a[i]&& i<=high);
do
j--;
while(key<a[j]);
if(i<j)
{
temp=a[i];
a[i]=a[j];
a[j]=temp;
34
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
}
temp=a[low];
a[low]=a[j];
a[j]=temp;
return j;
}
public static void qs (int a[],int low, int high)
{
int mid;
if(low<high)
{
mid=partition(a,low,high);
qs(a,low,mid-1);
qs(a,mid+1,high);
}
}
public static void main(String args[])
{
int n,i;
Scanner in=new Scanner(System.in);
Random rand=new Random();
System.out.println("Quicksort Test");
/* Accept no.of Elements */
System.out.println("\nEnter the number of elements");
n=in.nextInt();
/* create array of n elements */
int arr[]=new int[max];
try{
/* Generate Random Numbers */
for(i=0;i<n;i++)
35
arr[i]=rand.nextInt(100);
/* Print random numbers */
System.out.println("\nthe random elements are ");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long start_time=System.nanoTime();
/*call method Quick Sort*/
qs(arr,0,n-1);
long end_time=System.nanoTime();
/* Print Sorted Array */
System.out.println("\nThe Elements After sorting");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long t=end_time - start_time;
System.out.println(“Time taken for execution is:”+t+” nanoseconds);
}
catch(ArrayIndexOutOfBoundsException ae)
{
System.out.println("Array Index reached maximum ");
}
}
}
Output:
Quicksort Test
Enter the number of elements
10
the random elements are
17
31
81
44
91
24
36
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
87
42
57
17
The Elements after sorting
17
17
24
31
42
44
57
81
87
91
Time taken for execution is:6316 nanoseconds
Note: For n=5000 to 50000 in step of 5000 note down the time in nanoseconds. Convert time in
seconds and plot the graph with n as x axis and time as y axis.
37
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
b) The elements read from a file
Create a text file in notepad and enter random numbers one in each line. Save the file as t.txt
import java.util.Random;
import java.util.Scanner;
public class QuickSort
{
static int max=50000;
public static int partition(int a[],int low,int high)
{
int i,j,temp,key;
key=a[low];
i=low;
j=high+1;
while(i<=j)
{
do
i++;
while (key>=a[i]&& i<=high);
do
j--;
while(key<a[j]);
if(i<j)
{
temp=a[i];
a[i]=a[j];
a[j]=temp;
}
}
temp=a[low];
a[low]=a[j];
38
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
a[j]=temp;
return j;
}
public static void qs (int a[],int low, int high)
{
int mid;
if(low<high)
{
mid=partition(a,low,high);
qs(a,low,mid-1);
qs(a,mid+1,high);
}
}
public static void main(String args[])
{
int n,i;
FILE *f1;
int line[50];
int limit;
System.out.println("Quicksort Test");
/* Accept no.of Elements */
System.out.println("\nEnter the number of elements");
n=in.nextInt();
/* create array of n elements */
int arr[]=new int[max];
try{
/* Elements from file are: */
f1= fopen(“t.txt”,”r”);
while(i<= n-1) && (fgets(line,50,f1)!=NULL))
{
fscanf(line,”%d”,&limit);
39
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
arr[i] = limit;
i++;
}
fclose(f1);
/* Print random numbers */
System.out.println("\nthe random elements are ");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long start_time=System.nanoTime();
/*call method Quick Sort*/
qs(arr,0,n-1);
long end_time=System.nanoTime();
/* Print Sorted Array */
System.out.println("\nThe Elements After sorting");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long t=end_time - start_time;
System.out.println(“Time taken for execution is:”+t+” nanoseconds);
}
catch(ArrayIndexOutOfBoundsException ae)
{
System.out.println("Array Index reached maximum ");
}
}
}
40

Output:
Quicksort Test
Enter the number of elements 10
the random elements are
17
31
81
44
91
24
87
42
57
17
The Elements After sorting
17
17
24
31
42
44
57
81
87
91
Time taken for execution is: 6316 nanoseconds
41

2. Sort a given set of n integer elements using Merge Sort method and compute its time
complexity. Run the program for varied values of n> 5000, and record the time taken to
sort. Plot a graph of the time taken versus n. The elements can be read from a file or can be
generated using the random number generator. Demonstrate using C++/Java how the
divide-and-conquer method works along with its time complexity analysis: worst case,
average case and best case.
Merge Sort method using divide and Conquer Technique:
Merge sort is a perfect example of a successful application of the divide and conquer technique. It sorts
a given array a[0…n-1] by dividing it into two halves a[0….mid-1] and a[mid+1….high], sorting each
of them recursively, and then merging the two smaller sorted arrays into a single sorted one.
Pseudocode : Mergesort(a,low , high)
//a[low:high] is a global array to be sorted
{
if low<high then
{
//divide the problem into sub problem
mid=(low+high)/2
Mergesort(a,low,mid)
Mergesort(a,mid+1,high)
Merge(a,low,mid,high)
}
}
Pseudocode : Merge(a,low,mid,high)
//a[low:high] is a global array containing two sorted subsets in a[low:mid] and in a[mid+1:high].
//Merge two sets into a single set in a[low:high],b[] is an auxiliary global array.
{
h<-low
i<-low
j<-mid+1
while h<=mid && j<=high do
{
if a[h]<=a[j] then
{
b[i] <- a[h]
h++
}
else
{
b[i] <- a[j]
42
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
j++
}
i++
}
if h>mid then
for k=j to high do
{
b[i] <- a[k]
i++
}
else
for k=h to mid do
{
b[i] <- a[k]
i++
}
for k=low to high do
a[k] <- b[k]
}
Program 2
import java.util.Random;
import java.util.Scanner;
public class MergeSort
{
static int max=50000;
public static void mergesort(int a[],int low,int high)
{
 int mid;
 if(high>low)
 {
 mid=(low+high)/2;
 mergesort(a,low,mid);
 mergesort(a,mid+1,high);
 merge(a,low,mid,high);
 }
43
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
 }
public static void merge(int a[],int low,int mid,int high)
{
 int k=low,j=mid+1,i=low;
 int c[]=new int[1000];
 while((i<=mid)&&(j<=high))
 {
 if(a[i]<=a[j])
 {
 c[k]=a[i];
 i=i+1;
 }
 else
 {
 c[k]=a[j];
 j=j+1;
 }
 k=k+1;
}
while(i<=mid)
{
 c[k]=a[i];
 k=k+1;
 i=i+1;
}
while(j<=high)
{
 c[k]=a[j];
 k=k+1;
 j=j+1;
}
44
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
for(i=low;i<=high;i++)
a[i]=c[i];
}
public static void main(String args[] )
{
int n,i;
Scanner in=new Scanner(System.in);
Random rand=new Random();
System.out.println("MergeSort Test");
/* Accept no.of Elements */
System.out.println("\nEnter the number of elements");
n=in.nextInt();
/* create array of n elements */
int arr[]=new int[max];
try{
/* Generate Random Numbers */
for(i=0;i<n;i++)
arr[i]=rand.nextInt(100);
/* Print random numbers */
System.out.println("\nthe random elements are ");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long start_time=System.nanoTime();
/*call method merge Sort*/
mergesort(arr,0,n-1);
long end_time=System.nanoTime();
/* Print Sorted Array */
System.out.println("\nThe Elements After sorting");
for(i=0;i<n;i++)
System.out.println(arr[i]+" ");
long t=end_time - start_time;
45
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
System.out.println(“Time taken for execution is:”+t+” nanoseconds);
}
catch(ArrayIndexOutOfBoundsException ae)
{
System.out.println("Array Index reached maximum ");
}
}
}
Output:
MergeSort Test
Enter the number of elements
10
the random elements are
71
66
52
97
59
48
84
32
53
54
The Elements After sorting
32
48
52
53
54
59
66
71
84
97
Time taken for execution is:21316 nanoseconds
Note: For n=5000 to 50000 in step of 5000 note down the time in nanoseconds. Convert time in
seconds and plot the graph with n as x axis and time as y axis.
46


Module 3
1. Write & Execute C++/Java Program to solve Knapsack problem using Greedy method.
Fractional (Continuous) Knapsack using Greedy Method
Algorithm:
- Assume knapsack holds weight W and items have value vi and weight wi
- Rank items by value/weight ratio: vi / wi
- Thus: vi / wi ≥ vi+1 / wi+1
- Consider items in order of decreasing ratio
- Take as much of each item as possible
Pseudocode: GreedyKnapsack(m,n)
//p[1:n] and w[1:n] – contains the profits and weights of n objects ordered such that
//p[i]/w[i] >= p[I+1]/w[i+1]
//m is size of knapsack and x[1:n] is the solution vector
{
 for i<- 1 to n do
x[i]=0.0
u <- m
 for i <- 1 to n do
 {
if (w[i] > u) then break
x[i] <- 1.0
u <- u-w[i]
 }
 if (i<=n) then
 x[i]=u / w[i]
}
Program 1
import java.util.Scanner;
public class Knapsack
{
public static void knapsack(int n, int item[],float weight[], float profit[], float capacity)
{
float tp = 0,u;
int i;
47

u = capacity;
float x[]=new float[20];
for (i = 0; i < n; i++)
x[i] = (float) 0.0;
for (i = 0; i < n; i++)
{
 if (weight[i] > u)
 break;
 else {
 x[i] = (float) 1.0;
 tp = tp + profit[i];
 u = (int) (u - weight[i]);
 }
 }
 if (i < n)
 x[i] = u / weight[i];
 tp = tp + (x[i] * profit[i]);
 System.out.println("\nThe result vector is:- ");
 for (i = 0; i < n; i++)
 System.out.println("\tItem "+item[i]+":" +x[i]);
 System.out.println("\nMaximum profit is:- " +tp);
}
public static void main(String[] args)
{
 float weight[]=new float[20];
 float profit[]=new float[20];
 float capacity;
 int num, i, j;
 float ratio[]=new float[20], temp;
 int item[]=new int[10];
48

 Scanner in=new Scanner(System.in);
 System.out.println("\nEnter the no. of objects:- ");
 num=in.nextInt();
 System.out.println("\nEnter the the items, weights and profits of each object:- ");
 for (i = 0; i < num; i++)
 {
 item[i]=in.nextInt();
 weight[i]=in.nextFloat();
 profit[i]=in.nextFloat();
 }
 System.out.println("\nEnter the capacityacity of knapsack:- ");
 capacity=in.nextFloat();
 for (i = 0; i < num; i++)
 {
 ratio[i] = profit[i] / weight[i];
 }
 for (i = 0; i < num; i++)
 {
 for (j = i + 1; j < num; j++)
 {
 if (ratio[i] < ratio[j])
 {
 temp = ratio[j];
 ratio[j] = ratio[i];
 ratio[i] = temp;
 temp = weight[j];
 weight[j] = weight[i];
 weight[i] = temp;
 temp = profit[j];
49

 profit[j] = profit[i];
 profit[i] = temp;
temp=item[j];
item[j]=item[i];
item[i]=(int)temp;
 }
 }
 }
 knapsack(num, item,weight, profit, capacity);
}
}
Output:
Enter the no. of objects:-
3
Enter the items, wts and profits of each object:-
2 15 24
3 10 15
1 18 25
Enter the capacity of knapsack:-
20
The result vector is:-
Item 2:1.0
Item 3:0.5
Item 1:0.0
Maximum profit is:- 31.5
50
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
2. Write & Execute C++/Java Program to find shortest pathsto other vertices from a given
vertex in a weighted connected graph, using Dijkstra's algorithm.
Single Source Shortest Paths Problem using Greedy Method :( Dijkstra’s algorithm )
For a given vertex called the source in a weighted connected graph, find the shortest paths to all
its other vertices. Dijkstra’s algorithm is the best known algorithm for the single source shortest
paths problem. This algorithm is applicable to graphs with nonnegative weights only and finds
the shortest paths to a graph’s vertices in order of their distance from a given source. It finds the
shortest path from the source to a vertex nearest to it, then to a second nearest, and so on. It is
applicable to both undirected and directed graphs
Example:
Pseudocode:
findmin( )
{
for i ← to n do
if (s[i] = 0) do
{
min ← i
break
}
for i ← 1 to n do
{
if (d[i]<d[min] & s[i]=0)
min ← i
}
return min
}
dijkstra( )
{
for i ← to n do
{
s[i] ← 0
d[i] ← 999
p[i] ← 0
}
d[v] ← 0
for k ← 1 to n do
1 2
3
2
3 4
51
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
{
u ← findmin( )
s[u] ← 1
for w1 ←1 to n do
{
if (w[u][w1]!=999 & s[w1] = 0)
{
if (d[w1]>d[u]+w[u][w1] )
{
d[w1] ← d[u]+w[u][w1]
p[w1] ←u
}
}
}
}
display "shortest path costs"
for i ←1 to n do
{
if (d[i]=999)
display "sorry!no path for source v to vertex i"
else
display “path cost from v to i is d[i]”
}
display "shortest group of paths are"
for i ←1 to n do
{
if i!=v & d[i]!=999
{
display i
j ←p[i]
while p[j]!=0 do
{
print "" j
j ← p[j];
}
print ""v
}
}
}
main( )
{
 accept number of vertices n
accept weight matrix 999 for ∞
accept source vertex
call dijkstra( )
}
52
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Program 2
import java.util.Scanner;
public class Dijkstra
{
public static int findmin()
{
int i,n,min=0;
int d[]=new int[20];
int s[]=new int[20];
Scanner in=new Scanner(System.in);
n=in.nextInt();
for(i=1;i<=n;i++)
{
if(s[i]==0)
{
min=i;
break;
}
}
for(i=1;i<=n;i++)
{
if(d[i]<d[min] && s[i]==0)
min=i;
}
return min;
53
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
public void dijkstra(int v,int w[][],int s[],int d[],int n)
{
int i,w1,u,k,j;
int p[]=new int[20];
for(i=1;i<=n;i++)
{
s[i]=0;
d[i]=999;
p[i]=0;
}
d[v]=0;
for(k=1;k<=n;k++)
{
 u=findmin();
 s[u]=1;
for(w1=1;w1<=n;w1++)
{
if(w[u][w1]!=999 && s[w1]==0)
{
if(d[w1]>d[u]+w[u][w1])
{
d[w1]=d[u]+w[u][w1];
p[w1]=u;
}
54
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
}
}
System.out.println("shortest path costs\n");
for(i=1;i<=n;i++)
{
if(d[i]==999)
System.out.println("sorry! no path for source" + v + "to" + i + "vertex");
else
System.out.println("path cost from" +v+ "to" +i+ "is:" +d[i]+"\n");
}
System.out.println("shortest group of paths are\n");
for(i=1;i<=n;i++)
{
if(i!=v && d[i]!=999)
{
System.out.print(i);
j=p[i];
while(p[j]!=0)
{
System.out.println("<----"+ j +" ");
j=p[j];
}
System.out.println("<----"+ v +"\n");
}
55
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
}
public static void main(String args[])
{
int i,j,n,v;
int d[]=new int[20];
int s[]=new int[20];
int w[][]=new int[50][50];
Dijkstra d1 = new Dijkstra();
Scanner in=new Scanner(System.in);
System.out.println("enter the number of vertices\n");
n=in.nextInt();
System.out.println("enter the cost of vertices\n");
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
{
w[i][j]=in.nextInt();
}
System.out.println("enter the source vertex\n");
v=in.nextInt();
 /* call Dijkstra method */
d1.dijkstra(v,w,s,d,n);
}
}
Output:
56
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
enter the number of vertices
3
enter the cost of vertices
999 2 3
2 999 4
3 4 999
enter the source vertex
1
shortest path costs
path cost from1to1is:0
path cost from1to2is:2
path cost from1to3is:3
shortest group of paths are
2<----1
3<----1
57
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
3. Write & Execute C++/Java Program to find Minimum Cost Spanning Tree of a given
connected undirected graph using Kruskal's algorithm. Use Union-Find algorithms in
your program.
Kruskal’s Algorithm using Greedy method
Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree
and connects all the vertices together. A single graph can have many different spanning
trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted,
connected and undirected graph is a spanning tree with weight less than or equal to the weight of
every other spanning tree. The weight of a spanning tree is the sum of weights given to each
edge of the spanning tree.
Below are the steps for finding MST using Kruskal’s algorithm
1. Sort all the edges in non-decreasing order of their weight.
2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If
 cycle is not formed, include this edge. Else, discard it.
3. Repeat step2 until there are (V-1) edges in the spanning tree.
The step2 uses Union-Find algorithm to detect cycle.
A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned
into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that
performs two useful operations on such a data structure:
Find: Determine which subset a particular element is in. This can be used for determining if two
elements are in the same subset.
Union: Join two subsets into a single subset.
In this post, we will discuss an application of Disjoint Set Data Structure. The application is to
check whether a given graph contains a cycle or not.
Union-Find Algorithm can be used to check whether an undirected graph contains cycle or not.
This method is based on Union-Find. This method assumes that graph doesn’t contain any selfloops.
Pseudocode: Kruskal(G)
 //Kruskal’s algorithm for constructing a minimum spanning tree
 // Input: A weighted connected graph G=V, E
 // Output: ET , the set of edges composing a minimum spanning tree of G
 Sort E in non-decreasing order of the edge weights w(ei1)<=…<=w(ei|E|)
ET ; ecounter  0 //initialise the set of tree edges and its size
k  0 //initialise the number of processed edges
while ecounter < |V| - 1
kk+1
if ET  {eik}is acyclic
ETET  {eik}; ecounter  ecounter+1
Return ET
58
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Program 3
import java.util.Scanner;
public class Kruskal
{
public static int find(int v,int s[])
{
while(s[v]!=v)
v=s[v];
return v;
}
public static void union1(int i,int j,int s[])
{
s[i]=j;
}
public static void kruskal(int n,int c[][])
{
int count,i,min,j,u=0,v=0,k,sum;
int s[]= new int[10];
int t[][]=new int[10][2];
for(i=0;i<n;i++)
s[i]=i;
count=0;
59
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
sum=0;
k=0;
while(count<n-1)
{
min=999;
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
if(c[i][j]!=0 && c[i][j]<min)
{
min=c[i][j];
u=i;
v=j;
}
}
}
if(min==999) break;
i=find(u,s);
j=find(v,s);
if(i!=j)
{
t[k][0]=u;
t[k][1]=v;
k++;
60
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
count++;
sum+=min;
union1(i,j,s);
}
c[u][v]=c[v][u]=999;
}
if(count==n-1)
{
System.out.println("cost of spanning tree=" +sum+ "\n");
System.out.println("spanning tree is\n");
for(k=0;k<n-1;k++)
{
System.out.println("\n"+t[k][0]+","+t[k][1]);
}
}
System.out.println("spanning treee doesn't exist");
}
public static void main(String args[])
{
int n,i,j;
int c[][]=new int[10][10];
Scanner in=new Scanner(System.in);
System.out.println("Enter no of nodes\n");
n=in.nextInt();
System.out.println("Enter the cost adjacency matrix\n");
61
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
c[i][j]=in.nextInt();
}
}
kruskal(n,c);
}
}
Output:
Enter no of nodes
6
Enter the cost adjacency matrix
999 3 999 999 6 5
3 999 1 999 999 4
999 1 999 6 999 4
999 999 6 999 8 5
6 999 999 8 999 2
5 4 4 5 2 999
cost of spanning tree=15
spanning tree is
1,2
4,5
0,1
1,5
3,5
62
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
4. Write & Execute C++/Java Program to find Minimum Cost Spanning Tree of a given
connected undirected graph using Prim's algorithm.
Prim’s Algorithm using greedy Method
Prim’s algorithm constructs a minimum spanning tree through a sequenceof expanding subtrees.
The initial subtree in such a sequence consists of a single vertex selected arbitrarily from the set
V of the graph’s vertices. On each iteration, the algorithm expands the current tree in the greedy
manner by simply attaching to it the nearest vertex not in that tree. (By the nearest vertex, we
mean a vertex not in the tree connected to a vertex in the tree by an edge of the smallest weight.
Ties can be broken arbitrarily.) The algorithm stops after all the graph’s vertices have been
included in the tree being constructed. Since the algorithm expands a treeby exactly one vertex
on each of its iterations, the total number of such iterations is n − 1, where n is the number of
vertices in the graph. The tree generated by the algorithm is obtained as the set of edges used for
the tree expansions.
Pseudocode:Prim(G)
//Prim’s algorithm for constructing a minimum spanning tree
//Input: A weighted connected graph G = {V, E}
//Output: Et, the set of edges composing a minimum spanning tree of G
Vt←{v0} //the set of tree vertices can be initialized with any vertex
Et←∅
for i ←1 to |V| − 1 do
find a minimum-weight edge e∗ = (v∗, u∗) among all the edges (v, u)
such that v is in Vtand u is in V − Vt
Vt←Vt ∪ {u∗}
Et←Et ∪ {e∗}
return Et
Program 4
import java.util.Scanner;
public class prims
{
public static void main(String args[])
{
int n,i,j,min=0,a=0,u = 0,b=0,v = 0,source;
int ne=1;
int min_cost=0;
63
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
int cost[][]=new int[20][20];
int visited[]=new int[20];
Scanner in=new Scanner(System.in);
System.out.println("Enter the no. of nodes:");
n=in.nextInt();
System.out.println("Enter the cost matrix:\n");
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
cost[i][j]=in.nextInt();
}
}
for(i=1;i<=n;i++)
visited[i]=0;
System.out.println("Enter the root node:");
source=in.nextInt();
visited[source]=1;
System.out.println("\nMinimum cost spanning tree is\n");
while(ne<n)
{
min=999; for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
64
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
if(cost[i][j]<min) if(visited[i]==0)
continue;
else
{
min=cost[i][j];
a=u=i;
b=v=j;
}
}
}
if(visited[u]==0||visited[v]==0)
{
ne++;
System.out.println("\nEdge" + ne + "\t" +a+ "->" +b+ "=" +min+"\n");
min_cost=min_cost+min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
System.out.println("\nMinimum cost="+min_cost+"\n");
}
}
Output:
Enter the no. of nodes:
4
Enter the cost matrix:
65
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
999 1 5 2
1 999 999 999
5 999 999 3
2 999 3 999
Enter the root node:
1
Minimum cost spanning tree is
Edge2 1->2=1
Edge3 1->4=2
Edge4 4->3=3
Minimum cost=6
66
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Module 4
1) Write C++/ Java programs to solve All-Pairs Shortest Paths problem using Floyd's
algorithm.
.
Floyd’s Algorithm for All-Pairs Shortest-Paths Problem using Dynamic Programming
Given a weighted connected graph (undirected or directed), the all-pairs shortest paths problem
asks to find the distances—i.e., the lengths of the shortest paths—from each vertex to all other
vertices. This is one of several variations of the problem involving shortest paths in graphs.
Because of its important applications to communications, transportation networks, and
operations research, it has been thoroughly studied over the years. Among recent applications of
the all-pairs shortest-path problem is precomputing distances for motion planning in computer
games.
It is convenient to record the lengths of shortest paths in an n × n matrix D called the distance
matrix: the element dij in the ith row and the jth column of this matrix indicates the length of the
shortest path from the ith vertex to the jth vertex. We can generate the distance matrix with an
algorithm that is very similar toWarshall’s algorithm. It is called Floyd’s algorithm after its coinventor Robert W. Floyd. It is applicable to both undirected and directed weighted graphs
provided that they do not contain a cycle of a negative length. (The distance between any two
vertices in such a cycle can be made arbitrarily small by repeating the cycle enough times.) The
algorithm can be enhanced to find not only the lengths of the shortest paths for all vertex pairs
but also the shortest paths themselves.
Floyd’s algorithm computes the distance matrix of a weighted graph with n vertices through a
series of n × n matrices:
D(0), . . . , D(k−1), D(k), . . . , D(n).
Pseudocode:Floyd(W[1..n, 1..n])
//Implements Floyd’s algorithm for the all-pairs shortest-paths problem
//Input: The weight matrix W of a graph with no negative-length cycle
//Output: The distance matrix of the shortest paths’ lengths
D ←W //is not necessary if W can be overwritten
for k←1 to n do
for i ←1 to n do
for j ←1 to n do
D[i, j ]←min{D[i, j ], D[i, k]+ D[k, j]}
return D
Program 1
import java.util.Scanner;
public class Floyds {
public static void floyd(int a[][],int n)
67
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
{
int i,j,k;
int d[][]=new int[10][10];
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
d[i][j]=a[i][j];
}
}
for(k=1;k<=n;k++)
{
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}
}
}
System.out.println("\nThe distance matrix is\n");
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
68
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
System.out.print(+d[i][j]+"\t");
}
System.out.println("\n");
}
}
public static int min (int a,int b)
{
if(a<b)
return a;
else
return b;
}
public static void main(String args[])
{
int n,i,j;
int a[][]=new int[10][10];
Scanner sc=new Scanner(System.in);
System.out.println("Enter the no.of nodes : ");
n=sc.nextInt();
System.out.println("\nEnter the cost adjacency matrix");
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
a[i][j]= sc.nextInt();
floyd(a,n);
}
}
69
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Output:
Enter the no.of nodes :
4
Enter the cost adjacency matrix
0 999 3 999
2 0 999 999
999 7 0 1
6 999 999 0
The distance matrix is
0 10 3 4
2 0 5 6
7 7 0 1
6 16 9 0
70
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
2) Write C++/ Java programs to solve Travelling Sales Person problem using Dynamic
programming.
Travelling Salesman Problem(TSP) using Dynamic Programming
Given a set of cities and distance between every pair of cities, the problem is to find the shortest
possible route that visits every city exactly once and returns to the starting point.
Note the difference between Hamiltonian Cycle and TSP. The Hamiltonian cycle problem is to
find if there exists a tour that visits every city exactly once. Here we know that Hamiltonian Tour
exists (because the graph is complete) and in fact many such tours exist, the problem is to find a
minimum weight Hamiltonian Cycle.
For example, consider the graph shown in figure on right side. A TSP tour in the graph is 1-2-4-
3-1. The cost of the tour is 10+25+30+15 which is 80.The problem is a famous NP hard problem.
There is no polynomial time know solution for this problem.
Following are different solutions for the travelling salesman problem.
Naive Solution:
1) Consider city 1 as the starting and ending point.
2) Generate all (n-1)! Permutations of cities.
3) Calculate cost of every permutation and keep track of minimum cost permutation.
4) Return the permutation with minimum cost.
Time Complexity: (n!)
Dynamic Programming:
Denote the cities by 1,...,n, the starting city being 1, and let D = (dij) be the matrix of intercity
distances. The goal is to design a tour that starts and ends at 1, includes all other cities exactly
once, and has minimum total length. Figure shows an example involving five cities.
71
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Let's dive right into the DP. So what is the appropriate sub-problem for the TSP? In this case the
most obvious partial solution is the initial portion of a tour. Suppose we have started at city 1 as
required, have visited a few cities, and are now in city j. What information do we need in order to
extend this partial tour? We certainly need to know j, since this will determine which cities are
most convenient to visit next. And we also need to know all the cities visited so far, so that we
don’t repeat any of them. Here, then, is an appropriate sub-problem.
For a subset of cities S ⊆ {1,2,...,n} that includes 1, and j ∈ S, let C(S,j) be the length of the
shortest path visiting each node in S exactly once, starting at 1 and ending at j.
When |S| > 1, we define C(S, 1) = ∞ since the path cannot both start and end at 1.
Now, let’s express C(S,j) in terms of smaller sub-problems. We need to start at 1 and end at j;
what should we pick as the second-to-last city? It has to be some i ∈ S, so the overall path length
is the distance from 1 to i, namely, C(S − {j}, i), plus the length of the final edge, dij.
We must pick the best such i:
C(S,j)=mini∈S:i≠jC(S−{j},i)+dij
The sub-problems are ordered by |S|. Here’s the code.
C({1},1) = 0
for s = 2 to n:
 for all subsets S ⊆ {1,2,...,n} of size s and containing 1:
 C(S,1) = ∞
 for all j∈S,j≠1:
 C(S, j) = min{C(S−{j},i)+dij:i∈S,i≠j}
return minjC({1,...,n},j)+dj1
There are at most 2n.n sub-problems, and each one takes linear time to solve.
The total running time is therefore O(n
2
.2n
)
Program 2
import java.util.Scanner;
public class Tsp
72
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
{
final static int MAX=100;
final static int INFINITY=999;
static int tsp_dp(int c[][],int tour[],int start,int n)
{
int i,j,k;
int temp[]=new int[MAX];
int mintour[]=new int[MAX];
int mincost,ccost;
if(start==n-2)
return(c[tour[n-2]][tour[n-1]]+c[tour[n-1]][0]);
mincost=INFINITY;
for(i=start+1;i<n;i++)
{
for(j=0;j<n;j++)
temp[j]=tour[j];
temp[start+1]=tour[i];
temp[i]=tour[start+1];
if(c[tour[start]][tour[i]]+(ccost=tsp_dp(c,temp,start+1,n))<mincost)
{
mincost=ccost+c[tour[start]][tour[i]];
for(k=0;k<n;k++)
mintour[k]=temp[k];
}
}
73
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
for(i=0;i<n;i++)
tour[i]=mintour[i];
tour[i]=start;
return mincost;
}
public static void main(String[] args)
{
 int n,i,j,cost;
 int c[][]=new int[MAX][MAX];
 int tour[]=new int[MAX];
 Scanner sc=new Scanner(System.in);
 System.out.println("Enter the number of cities:");
 n=sc.nextInt();
 System.out.println("Enter the cost matrix\n");
 for(i=0;i<n;i++)
 for(j=0;j<n;j++)
 c[i][j]=sc.nextInt();
 for(i=0;i<n;i++)
 tour[i]=i;
 cost=tsp_dp(c,tour,0,n);
 System.out.println("\nmincost by dp:"+cost);
 System.out.println("\ntour: ");
 for(i=0;i<n;i++)
 System.out.print(tour[i]+1 +"\t");
}
74
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
Output:
Enter the number of cities:
5
Enter the cost matrix
0 3 1 5 8
3 0 6 7 9
1 6 0 4 2
5 7 4 0 3
8 9 2 3 0
mincost by dp:16
tour:
1 2 4 5 3
75
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
3. Write C++/ Java programs to solve 0/1 Knapsack problem using Dynamic
Programming method.
Given weights and values of n items, put these items in a knapsack of capacity W to get the
maximum total value in the knapsack. In other words, given two integer arrays val[0..n-1] and
wt[0..n-1] which represent values and weights associated with n items respectively. Also given
an integer W which represents knapsack capacity, find out the maximum value subset of val[]
such that sum of the weights of this subset is smaller than or equal to W. You cannot break an
item, either pick the complete item, or don’t pick it (0-1 property).
A simple solution is to consider all subsets of items and calculate the total weight and value of all
subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets,
pick the maximum value subset.
Optimal Substructure:
To consider all subsets of items, there can be two cases for every item:
(1) the item is included in the optimal subset, (2) not included in the optimal set.
Therefore, the maximum value that can be obtained from n items is max of following two values.
1) Maximum value obtained by n-1 items and W weight (excluding nth item).
2) Value of nth item plus maximum value obtained by n-1 items and W minus weight of the nth
item (including nth item).
If weight of nth item is greater than W, then the nth item cannot be included and case 1 is the
only possibility.
0/1(Discrete) Knapsack Pseudocode:
max(a,b)
{
return(a>b)?a:b;
}
knap(i, j)
{
if(i=0 or j=0) then
v[i][j]=0
elseif(j<w[i]) then
v[i][j]=knap(i-1,j)
else
v[i][j]=max(knap(i-1,j), value[i]+knap(i-1,j-w[i]))
returnv[i][j]
 }
 optimal( i,j)
 {
if(i>=1 or j>=1) then
76
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
if(v[i][j]!=v[i-1][j]) then
{
Print Item i
b[i]=1
j=j-w[i]
optimal(i-1,j)
}
else
optimal(i-1,j);
 }
Program 3
import java.util.Scanner;
public class Knapsack1
{
private static int w[]=new int[10];
private static int b[]=new int[10];
private static int v[][]=new int[10][10];
private static int value[]=new int[10];
static int max(int a, int b)
{
return(a>b)?a:b;
}
static int knap(int i,int j)
{
if(i==0 || j==0)
v[i][j]=0;
else if(j<w[i])
v[i][j]=knap(i-1,j);
else
v[i][j]=max(knap(i-1,j), value[i]+knap(i-1,j-w[i]));
return v[i][j];
}
static void optimal(int i,int j)
77
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
{
if(i>=1 || j>=1)
if(v[i][j]!=v[i-1][j])
{
System.out.println("Item:"+i);
b[i]=1;
j=j-w[i];
optimal(i-1,j);
}
else
optimal(i-1,j);
}
public static void main(String[] args)
{
int profit, w1,n,i,j;
Scanner sc=new Scanner(System.in);
System.out.println("enter the number of items:");
n=sc.nextInt();
System.out.println("enter the capacity of the knapsack:");
w1=sc.nextInt();
System.out.println("enter the values:");
for(i=1;i<=n;i++)
value[i]=sc.nextInt();
System.out.println("enter the weights:");
for(i=1;i<=n;i++)
w[i]=sc.nextInt();
profit=knap(n,w1);
System.out.println("profit: "+profit);
System.out.println("\n optimal subset is:\n");
optimal(n,w1);
System.out.println("the solution vector is:");
78
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
for(i=1;i<=n;i++)
System.out.println(b[i]);
 }
}
Output:
enter the number of items:
4
enter the capacity of the knapsack:
2
enter the values:
3
45
4
3
enter the weights:
1
1
1
1
profit: 49
optimal subset is:
Item:3
Item:2
the solution vector is:
0
1
1
0
79
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
Module 5
1. Design and implement C++/Java Program to find a subset of a given set S = {Sl, S2,…,
Sn} of n positive integers whose SUM is equal to a given positive integer d. For example, if
S = {1, 2, 5, 6, 8} and d= 9, there are two solutions {1, 2, 6} and {1, 8}. Display a suitable
message, if the given problem instance doesn't have a solution.
Algorithm for Subset
Algorithm for main:
Step 1: accept number of elements
Step 2: accept set of elements
Step 3: accept maximum subset value
Step 4: print the subset cell sum of sub(0,1,sum)
Step 5: stop
Pseudocode:
sumofsub(0,1,sum)
{
x[k]=1
if(s +w[k] <- u)
{
print solution v++
for i<- 1 to n do
if x[i]=1
print w[i]
}
else if (s+ w[k] +w[k+] < = m) do
call sumofsub(s + w[k],k+1 , r-w[k])
if( s +r-w[k]>=m and s+w[k+] <=m) do
{
x[k]<-0
call sumofsub(s,k+1,r-w[k])
}
}
Program 1
import java.util.Scanner;
public class Subset
{
private static int d;
private static int count=0;
80
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
private static int x[]=new int[20];
private static int w[]=new int[20];
public static void main(String[] args)
{
Scanner sc=new Scanner(System.in);
int i,n,sum=0;
System.out.println("Enter the no. of elements: ");
n=sc.nextInt();
System.out.println("\nEnter the elements in ascending order:\n");
for(i=0;i<n;i++)
w[i]=sc.nextInt();
System.out.println("\nEnter the sum: ");
d=sc.nextInt();
for(i=0;i<n;i++)
sum=sum+w[i];
if(sum<d)
{
System.out.println("No solution\n");
return;
}
subset(0,0,sum);
if(count==0)
{
System.out.println("No solution\n");
return;
}
}
static void subset(int cs,int k,int r)
{
int i;
x[k]=1;
81
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
if(cs+w[k]==d)
{
System.out.println("\n\nSubset" +(++count));
for(i=0;i<=k;i++)
if(x[i]==1)
System.out.println(w[i]+" ");
}
else if(cs+w[k]+w[k+1]<=d)
{
subset((cs+w[k]),k+1,r-w[k]);
}
if(cs+r-w[k]>=d && cs+w[k]<=d)
{
x[k]=0;
subset(cs,k+1,r-w[k]);
}
}
}
Output:
Enter the no. of elements:
5
Enter the elements in ascending order:
1 2 5 6 8
Enter the sum:
9
Subset1
1
2
6
Subset2
1
8
82
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
2. Design and implement C++/Java Program to find all Hamiltonian Cycles in a connected
undirected Graph G of n vertices using backtracking principle.
Hamiltonian Path Problem using Backtracking Method
Hamiltonian Path is a path in a directed or undirected graph that visits each vertex exactly once.
The problem to check whether a graph (directed or undirected) contains a Hamiltonian Path is
NP-complete, so is the problem of finding all the Hamiltonian Paths in a graph. Following
images explains the idea behind Hamiltonian Path more clearly.

Graph shown in Fig.1 does not contain any Hamiltonian Path. Graph shown in Fig. 2 contains
two Hamiltonian Paths which are highlighted in Fig. 3 and Fig. 4
Following are some ways of checking whether a graph contains a Hamiltonian Path or not.
1. A Hamiltonian Path in a graph having N vertices is nothing but a permutation of the
vertices of the graph [v1, v2, v3, ......vN-1, vN] , such that there is an edge between vi and
vi+1 where 1 ≤ i ≤ N-1. So it can be checked for all permutations of the vertices whether
any of them represents a Hamiltonian Path or not. For example, for the graph given in
Fig. 2 there are 4 vertices, which means total 24 possible permutations, out of which only
following represents a Hamiltonian Path.
0-1-2-3
3-2-1-0
0-1-3-2
2-3-1-0
2. Pseudocode:
function check_all_permutations(adj[][], n)
{
for i = 0 to n
 p[i]=i
 while next permutation is possible
 valid = true
 for i = 0 to n-1
 if adj[p[i]][p[i+1]] == false
 valid = false
 break
 if valid == true
 return true
 p = get_next_permutation(p)
 return false
83
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
}
The function get_next_permutation(p) generates the lexicographically next greater permutation
than p.
Following is the C++ implementation:
bool check_all_permutations(bool adj[][MAXN], int n){
 vector<int>v;
 for(int i=0; i<n; i++)
 v.push_back(i);
 do{
 bool valid=true;
 for(int i=0; i<v.size()-1; i++){
 if(adj[v[i]][v[i+1]] == false){
 valid=false;
 break;
 }
 }
 if(valid)
 return true;
 }while(next_permutation(v.begin(), v.end()));
 return false;
}
Time complexity of the above method can be easily derived. For a graph having N vertices it
visits all the permutations of the vertices, i.e. N! iterations and in each of those iterations it
traverses the permutation to see if adjacent vertices are connected or not i.e N iterations, so the
complexity is O( N * N! ).
Program 2
public class Hamiltonian
{
 final int V = 5;
 int path[];
 /* A utility function to check if the vertex v can be added at index 'pos'in the Hamiltonian
 Cycle constructed so far (stored in 'path[]') */
 boolean isSafe(int v, int graph[][], int path[], int pos)
 {
 /* Check if this vertex is an adjacent vertex of the previously added vertex. */
 if (graph[path[pos - 1]][v] == 0)
return false;
84
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
/* Check if the vertex has already been included.This step can be optimized by creating
an arrayof size V */
for (int i = 0; i < pos; i++)
if (path[i] == v)
return false;
 return true;
 }
 /* A recursive utility function to solve hamiltonian cycle problem */
 boolean hamCycleUtil(int graph[][], int path[], int pos)
 {
 /* base case: If all vertices are included in Hamiltonian Cycle */
if (pos == V)
{
 // And if there is an edge from the last included
 // vertex to the first vertex
if (graph[path[pos - 1]][path[0]] == 1)
return true;
else
return false;
}
 /* Try different vertices as a next candidate in Hamiltonian Cycle. We don't try for 0 as
 We included 0 as starting point in hamCycle() */
 for (int v = 1; v < V; v++)
 {
 /* Check if this vertex can be added to Hamiltonian Cycle */
 if (isSafe(v, graph, path, pos))
{
 path[pos] = v;
 /* recur to construct rest of the path */
if (hamCycleUtil(graph, path, pos + 1) == true)
85
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
return true;
 /* If adding vertex v doesn't lead to a solution,then remove it */
 path[pos] = -1;
 }
 }
 /* If no vertex can be added to Hamiltonian Cycle constructed so far, then return false */
 return false;
 }
/* This function solves the Hamiltonian Cycle problem using Backtracking. It mainly uses
hamCycleUtil() to solve the problem. It returns false if there is no Hamiltonian Cycle
possible, otherwise return true and prints the path.Please note that there may be more
 than one solutions this function prints one of the feasible solutions. */
 int hamCycle(int graph[][])
 {
 path = new int[V];
 for (int i = 0; i < V; i++)
 path[i] = -1;
 /* Let us put vertex 0 as the first vertex in the path.If there is a Hamiltonian Cycle,
then the path can be started from any point of the cycle as the graph is undirected */
 path[0] = 0;
 if (hamCycleUtil(graph, path, 1) == false)
 {
 //System.out.println("\nSolution does not exist");
 return 0;
 }
 printSolution(path);
 return 1;
 }
86
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
 /* A utility function to print solution */
 void printSolution(int path[])
 {
 System.out.println("Solution Exists: Following" +" is one Hamiltonian Cycle");
 for (int i = 0; i < V; i++)
 System.out.print(" " + path[i] + " ");
 // Let us print the first vertex again to show the
 // complete cycle
 System.out.println(" " + path[0] + " ");
 }
 // driver program to test above function
 public static void main(String args[])
 {
 Hamiltonian hamiltonian =new Hamiltonian();
 /* Let us create the following graph
 (0)--(1)--(2)
 | / \ |
 | / \ |
 | / \ |
 (3)-------(4) */
 int graph1[][] = {{0, 1, 0, 1, 0},
 {1, 0, 1, 1, 1},
 {0, 1, 0, 0, 1},
 {1, 1, 0, 0, 1},
 {0, 1, 1, 1, 0},
 };
 // Print the solution
 hamiltonian.hamCycle(graph1);
 /* Let us create the following graph
87
Design and Analysis of Algorithms -21CS42- Laboratory Component
Dept. of CSE, SIR MVIT, Bengaluru AY2022-2023
 (0)--(1)--(2)
 | / \ |
 | / \ |
 | / \ |
 (3) (4) */
 int graph2[][] = {{0, 1, 0, 1, 0},
 {1, 0, 1, 1, 1},
 {0, 1, 0, 0, 1},
 {1, 1, 0, 0, 0},
 {0, 1, 1, 0, 0},
 };
 // Print the solution
 hamiltonian.hamCycle(graph2);
 }
}
Output:
Solution Exists: Following is one Hamiltonian Cycle
0 1 2 4 3 0
